@using Suendenbock_App.Models.ViewModels
@using Suendenbock_App.Data;
@model FamilyTreeViewModel
@{
    ViewData["Title"] = "Familienstammbaum";
}

<div class="container-fluid py-4">
    <div class="row justify-content-center">
        <div class="col-12">
            <!-- Header -->
            <div class="text-center mb-4">
                <h1 class="medieval-title" style="font-family: 'Cinzel', serif; color: #d4af37;">
                    üå≥ Familienstammbaum
                </h1>
                <p class="text-muted" style="font-family: 'Cinzel', serif;">
                    Familie: @Model.RootCharacter.Vorname @Model.RootCharacter.Nachname
                </p>
            </div>

            <!-- Character Selector -->
            <div class="row mb-4">
                <div class="col-md-6 mx-auto">
                    <form asp-controller="Home" asp-action="FamilyTree" method="get">
                        <div class="input-group">
                            <select class="form-select" name="characterId" onchange="this.form.submit()" style="font-family: 'Cinzel', serif;">
                                <option value="">Charakter ausw√§hlen...</option>
                                @foreach (var character in Context.RequestServices
                                .GetRequiredService<ApplicationDbContext>()
                                  .Characters.OrderBy(c => c.Nachname).ThenBy(c => c.Vorname).ToList())
                                {
                                    <option value="@character.Id" selected="@(character.Id == Model.RootCharacter.Id)">
                                        @character.Vorname @character.Nachname
                                    </option>
                                }
                            </select>
                            <button class="btn btn-primary" type="submit" style="font-family: 'Cinzel', serif;">Anzeigen</button>
                        </div>
                    </form>
                </div>
            </div>

            <!-- Tree Container -->
            <div class="card" style="background: rgba(255, 248, 220, 0.95); border: 2px solid #d4c4a8; border-radius: 15px; box-shadow: 0 4px 12px rgba(0,0,0,0.3);">
                <div class="card-body p-4">
                    <!-- Legend -->
                    <div class="text-center mb-3">
                        <small style="font-family: 'Cinzel', serif; color: #5d4e37;">
                            <strong>Navigation:</strong> Klicke auf die Nodes um Zweige zu expandieren oder zu kollabieren
                        </small>
                    </div>

                    <!-- Tree Chart -->
                    <div id="tree-container" style="overflow-x: auto; overflow-y: auto;">
                        <svg id="family-tree-chart"></svg>
                    </div>

                    <!-- Tooltip -->
                    <div id="tooltip" style="
                        position: absolute;
                        display: none;
                        background: rgba(93, 78, 55, 0.95);
                        color: white;
                        padding: 10px 15px;
                        border-radius: 8px;
                        font-family: 'Cinzel', serif;
                        font-size: 0.9rem;
                        pointer-events: none;
                        z-index: 1000;
                        border: 2px solid #d4af37;
                        box-shadow: 0 4px 8px rgba(0,0,0,0.3);
                    "></div>
                </div>
            </div>

            <!-- Back Button -->
            <div class="text-center mt-4">
                <a href="@Url.Action("Index", "Home")" class="btn btn-outline-secondary" style="
                    font-family: 'Cinzel', serif;
                    border-color: #8b7355;
                    color: #5d4e37;
                ">
                    ‚Üê Zur√ºck zur Startseite
                </a>
            </div>
        </div>
    </div>
</div>

<!-- D3.js Library -->
<script src="https://d3js.org/d3.v7.min.js"></script>

<style>
    .medieval-title {
        text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
    }

    /* Tree specific styles */
    #family-tree-chart .node circle {
        cursor: pointer;
        stroke: #5d4e37;
        stroke-width: 2px;
    }

    #family-tree-chart .node text {
        font-family: 'Cinzel', serif;
        font-size: 14px;
        font-weight: 600;
        fill: #5d4e37;
        text-shadow: 1px 1px 2px rgba(255,255,255,0.8);
    }

    #family-tree-chart .link {
        fill: none;
        stroke: #8b7355;
        stroke-width: 2px;
    }

    #family-tree-chart .link.partner-link {
        stroke: #d4af37;
        stroke-width: 3px;
        stroke-dasharray: 5, 5;
    }

    #family-tree-chart .node circle:hover {
        stroke: #d4af37;
        stroke-width: 3px;
    }

    #family-tree-chart .node.partner circle {
        stroke: #d4af37;
        stroke-width: 3px;
    }
</style>

<script>
    // Mittelalterliches Farbschema
    const medievalColors = {
        gold: '#d4af37',
        darkBrown: '#5d4e37',
        mediumBrown: '#8b7355',
        lightBrown: '#a0826d',
        tan: '#c9a86a',
        parchment: '#f8f4e6',
        male: '#4a90e2',      // Blau f√ºr m√§nnlich
        female: '#e91e63'      // Pink f√ºr weiblich
    };

    // Farbzuweisung basierend auf Geschlecht
    function getNodeColor(d) {
        if (d.data.geschlecht === 'm√§nnlich' || d.data.geschlecht === 'M√§nnlich') {
            return medievalColors.male;
        } else if (d.data.geschlecht === 'weiblich' || d.data.geschlecht === 'Weiblich') {
            return medievalColors.female;
        }
        return medievalColors.tan;
    }

    // Lade Daten und erstelle bidirektionalen Tree
    fetch('@Url.Action("GetBidirectionalFamilyTreeData", "Home")?characterId=@Model.RootCharacter.Id')
        .then(response => response.json())
        .then(data => {
            createBidirectionalFamilyTree(data);
        })
        .catch(error => {
            console.error('Fehler beim Laden der Stammbaum-Daten:', error);
            document.getElementById('tree-container').innerHTML =
                '<div class="alert alert-danger">Fehler beim Laden der Daten. Bitte Seite neu laden.</div>';
        });

    function createBidirectionalFamilyTree(data) {
        // Dimensionen
        const margin = { top: 100, right: 200, bottom: 100, left: 200 };
        const width = 1400 - margin.left - margin.right;
        const height = 1000 - margin.top - margin.bottom;
        const centerY = height / 2;

        // SVG erstellen
        const svg = d3.select("#family-tree-chart")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom);

        const g = svg.append("g")
            .attr("transform", `translate(${margin.left},${margin.top})`);

        // Gruppen f√ºr verschiedene Elemente
        const linkGroup = g.append("g").attr("class", "links");
        const nodeGroup = g.append("g").attr("class", "nodes");

        //=== ROOT CHARACTER IN DER MITTE ===
        const rootNode = nodeGroup.append("g")
            .attr("class", "node root")
            .attr("transform", `translate(${width/2},${centerY})`);

        rootNode.append("circle")
            .attr("r", 12)
            .style("fill", medievalColors.parchment)
            .style("stroke", getNodeColorFromData(data.root))
            .style("stroke-width", 4);

        rootNode.append("text")
            .attr("dy", -20)
            .attr("text-anchor", "middle")
            .text(data.root.name)
            .style("font-weight", "bold")
            .style("font-size", "16px");

        //=== PARTNER (rechts neben Root) ===
        if (data.partner) {
            const partnerX = width/2 + 150;
            const partnerNode = nodeGroup.append("g")
                .attr("class", "node partner")
                .attr("transform", `translate(${partnerX},${centerY})`);

            partnerNode.append("circle")
                .attr("r", 10)
                .style("fill", medievalColors.parchment)
                .style("stroke", medievalColors.gold)
                .style("stroke-width", 3);

            partnerNode.append("text")
                .attr("dy", -15)
                .attr("text-anchor", "middle")
                .text(`üíç ${data.partner.name}`)
                .style("font-size", "14px");

            // Partner-Verbindungslinie
            linkGroup.append("line")
                .attr("x1", width/2 + 12)
                .attr("y1", centerY)
                .attr("x2", partnerX - 10)
                .attr("y2", centerY)
                .style("stroke", medievalColors.gold)
                .style("stroke-width", 3)
                .style("stroke-dasharray", "5,5");
        }

        //=== GESCHWISTER (links neben Root) ===
        if (data.siblings && data.siblings.length > 0) {
            const siblingSpacing = 80;
            const startY = centerY - ((data.siblings.length - 1) * siblingSpacing / 2);

            data.siblings.forEach((sibling, i) => {
                const siblingNode = nodeGroup.append("g")
                    .attr("class", "node sibling")
                    .attr("transform", `translate(${width/2 - 150},${startY + i * siblingSpacing})`);

                siblingNode.append("circle")
                    .attr("r", 8)
                    .style("fill", medievalColors.parchment)
                    .style("stroke", getNodeColorFromData(sibling))
                    .style("stroke-width", 2);

                siblingNode.append("text")
                    .attr("dy", -12)
                    .attr("text-anchor", "middle")
                    .text(sibling.name)
                    .style("font-size", "12px");
            });
        }

        //=== VORFAHREN (nach oben) ===
        if (data.ancestors) {
            renderAncestors(data.ancestors, width/2, centerY - 100, 0);
        }

        //=== NACHKOMMEN (nach unten) ===
        if (data.descendants) {
            renderDescendants(data.descendants, width/2, centerY + 100, 0);
        }

        function renderAncestors(ancestors, startX, startY, generation) {
            const spacing = 200 / Math.pow(2, generation);
            const parentSpacing = 200;

            ancestors.forEach((ancestor, i) => {
                const x = startX + (i === 0 ? -parentSpacing/2 : parentSpacing/2);
                const y = startY;

                const ancestorNode = nodeGroup.append("g")
                    .attr("class", "node ancestor")
                    .attr("transform", `translate(${x},${y})`)
                    .on("mouseover", function(event) { showTooltipData(event, ancestor); })
                    .on("mouseout", hideTooltip);

                ancestorNode.append("circle")
                    .attr("r", 8)
                    .style("fill", medievalColors.parchment)
                    .style("stroke", getNodeColorFromData(ancestor))
                    .style("stroke-width", 2);

                ancestorNode.append("text")
                    .attr("dy", -12)
                    .attr("text-anchor", "middle")
                    .text(ancestor.name)
                    .style("font-size", "12px");

                // Verbindung zum Kind
                linkGroup.append("path")
                    .attr("d", `M ${x},${y + 8} L ${x},${y + 50} L ${startX},${startY + 100} L ${startX},${startY + 92}`)
                    .style("fill", "none")
                    .style("stroke", medievalColors.mediumBrown)
                    .style("stroke-width", 2);

                // Rekursiv Eltern rendern
                if (ancestor.parents) {
                    renderAncestors(ancestor.parents, x, y - 100, generation + 1);
                }
            });
        }

        function renderDescendants(descendants, startX, startY, generation) {
            const childSpacing = 150 / (descendants.length + 1);
            const totalWidth = descendants.length * childSpacing;
            const startChildX = startX - (totalWidth / 2);

            descendants.forEach((child, i) => {
                const x = startChildX + (i + 0.5) * childSpacing;
                const y = startY;

                const childNode = nodeGroup.append("g")
                    .attr("class", "node descendant")
                    .attr("transform", `translate(${x},${y})`)
                    .on("mouseover", function(event) { showTooltipData(event, child); })
                    .on("mouseout", hideTooltip);

                childNode.append("circle")
                    .attr("r", 8)
                    .style("fill", medievalColors.parchment)
                    .style("stroke", getNodeColorFromData(child))
                    .style("stroke-width", 2);

                childNode.append("text")
                    .attr("dy", 25)
                    .attr("text-anchor", "middle")
                    .text(child.name)
                    .style("font-size", "12px");

                // Verbindung zu Eltern
                linkGroup.append("path")
                    .attr("d", `M ${x},${y - 8} L ${x},${y - 50} L ${startX},${startY - 100} L ${startX},${startY - 92}`)
                    .style("fill", "none")
                    .style("stroke", medievalColors.mediumBrown)
                    .style("stroke-width", 2);

                // Rekursiv Kinder rendern
                if (child.children) {
                    renderDescendants(child.children, x, y + 100, generation + 1);
                }
            });
        }

        function getNodeColorFromData(nodeData) {
            if (nodeData.geschlecht === 'm√§nnlich' || nodeData.geschlecht === 'M√§nnlich') {
                return medievalColors.male;
            } else if (nodeData.geschlecht === 'weiblich' || nodeData.geschlecht === 'Weiblich') {
                return medievalColors.female;
            }
            return medievalColors.tan;
        }

        function showTooltipData(event, nodeData) {
            const tooltip = document.getElementById('tooltip');
            let tooltipContent = `<strong>${nodeData.name}</strong><br/>`;
            tooltipContent += `Geschlecht: ${nodeData.geschlecht || 'Unbekannt'}<br/>`;
            if (nodeData.geburtsdatum) {
                tooltipContent += `Geboren: ${nodeData.geburtsdatum}<br/>`;
            }
            if (nodeData.type) {
                tooltipContent += `Beziehung: ${nodeData.type}`;
            }
            tooltip.innerHTML = tooltipContent;
            tooltip.style.display = 'block';
            tooltip.style.left = (event.pageX + 10) + 'px';
            tooltip.style.top = (event.pageY - 60) + 'px';
        }

        function hideTooltip() {
            const tooltip = document.getElementById('tooltip');
            tooltip.style.display = 'none';
        }
    }

    // Alte Funktion (optional behalten f√ºr R√ºckw√§rtskompatibilit√§t)
    function createFamilyTree_old(data) {
        // Dimensionen
        const margin = { top: 20, right: 120, bottom: 20, left: 120 };
        const width = 1200 - margin.left - margin.right;
        const height = 800 - margin.top - margin.bottom;

        // SVG erstellen
        const svg = d3.select("#family-tree-chart")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom);

        const g = svg.append("g")
            .attr("transform", `translate(${margin.left},${margin.top})`);

        // Separate Gruppen f√ºr Links (unten) und Nodes (oben)
        const linkGroup = g.append("g").attr("class", "links");
        const nodeGroup = g.append("g").attr("class", "nodes");

        // Tree Layout
        const tree = d3.tree()
            .size([height, width]);

        // Hierarchie erstellen
        const root = d3.hierarchy(data);
        root.x0 = height / 2;
        root.y0 = 0;

        // Variablen f√ºr die Update-Funktion
        var i = 0;
        const duration = 750;

        // Alle Kinder initial kollabieren (au√üer erste Ebene)
        if (root.children) {
            root.children.forEach(collapse);
        }

        update(root);

        function collapse(d) {
            if (d.children) {
                d._children = d.children;
                d._children.forEach(collapse);
                d.children = null;
            }
        }

        function update(source) {
            // Tree Layout anwenden
            const treeData = tree(root);
            const nodes = treeData.descendants();
            const links = treeData.links();

            // Normalisiere f√ºr feste Tiefe
            nodes.forEach(d => { d.y = d.depth * 200; });

            // **************** Nodes Sektion ****************

            // Update nodes
            const node = nodeGroup.selectAll('g.node')
                .data(nodes, d => d.id || (d.id = ++i));

            // Enter neue nodes
            const nodeEnter = node.enter().append('g')
                .attr('class', d => d.data.isPartner ? 'node partner' : 'node')
                .attr("transform", d => `translate(${source.y0},${source.x0})`)
                .on('click', click);

            // Circles f√ºr die nodes
            nodeEnter.append('circle')
                .attr('r', 1e-6)
                .style("fill", d => d._children ? getNodeColor(d) : medievalColors.parchment)
                .style("stroke", d => getNodeColor(d))
                .on("mouseover", function(event, d) {
                    d3.select(this)
                        .transition()
                        .duration(200)
                        .attr('r', 12);
                    showTooltip(event, d);
                })
                .on("mousemove", moveTooltip)
                .on("mouseout", function(event, d) {
                    d3.select(this)
                        .transition()
                        .duration(200)
                        .attr('r', 8);
                    hideTooltip();
                });

            // Labels f√ºr die nodes
            nodeEnter.append('text')
                .attr("dy", ".35em")
                .attr("x", d => d.depth === 0 ? -13 : 13)
                .attr("text-anchor", d => d.depth === 0 ? "end" : "start")
                .text(d => d.data.isPartner ? `üíç ${d.data.name}` : d.data.name)
                .style("fill-opacity", 1e-6);

            // Update
            const nodeUpdate = nodeEnter.merge(node);

            // Transition zur neuen Position
            nodeUpdate.transition()
                .duration(duration)
                .attr("transform", d => `translate(${d.y},${d.x})`);

            // Update circle Stil
            nodeUpdate.select('circle')
                .attr('r', 8)
                .style("fill", d => d._children ? getNodeColor(d) : medievalColors.parchment)
                .style("stroke", d => getNodeColor(d))
                .attr('cursor', 'pointer');

            // Update text
            nodeUpdate.select('text')
                .style("fill-opacity", 1);

            // Exit
            const nodeExit = node.exit().transition()
                .duration(duration)
                .attr("transform", d => `translate(${source.y},${source.x})`)
                .remove();

            nodeExit.select('circle')
                .attr('r', 1e-6);

            nodeExit.select('text')
                .style('fill-opacity', 1e-6);

            // **************** Links Sektion ****************

            // Update links
            const link = linkGroup.selectAll('path.link')
                .data(links, d => d.target.id);

            // Enter neue links
            const linkEnter = link.enter().append('path')
                .attr("class", d => d.target.data.isPartner ? "link partner-link" : "link")
                .attr('d', d => {
                    const o = { x: source.x0, y: source.y0 };
                    return diagonal(o, o);
                });

            // Update
            const linkUpdate = linkEnter.merge(link);

            // Transition zur neuen Position
            linkUpdate.transition()
                .duration(duration)
                .attr('d', d => diagonal(d.source, d.target));

            // Exit
            link.exit().transition()
                .duration(duration)
                .attr('d', d => {
                    const o = { x: source.x, y: source.y };
                    return diagonal(o, o);
                })
                .remove();

            // Speichere alte Positionen f√ºr Transition
            nodes.forEach(d => {
                d.x0 = d.x;
                d.y0 = d.y;
            });

            // Diagonale Pfad-Generator
            function diagonal(s, d) {
                return `M ${s.y} ${s.x}
                        C ${(s.y + d.y) / 2} ${s.x},
                          ${(s.y + d.y) / 2} ${d.x},
                          ${d.y} ${d.x}`;
            }

            // Toggle children on click
            function click(event, d) {
                if (d.children) {
                    d._children = d.children;
                    d.children = null;
                } else {
                    d.children = d._children;
                    d._children = null;
                }
                update(d);
            }
        }

        // Tooltip Funktionen
        function showTooltip(event, d) {
            const tooltip = document.getElementById('tooltip');
            const childCount = d.children ? d.children.length : (d._children ? d._children.length : 0);

            let tooltipContent = `<strong>${d.data.name}</strong><br/>`;

            if (d.data.isPartner) {
                tooltipContent += `<span style="color: #d4af37;">üíç Ehepartner</span><br/>`;
            }

            tooltipContent += `Geschlecht: ${d.data.geschlecht || 'Unbekannt'}<br/>`;
            if (d.data.geburtsdatum) {
                tooltipContent += `Geboren: ${d.data.geburtsdatum}<br/>`;
            }

            if (d.data.isPartner) {
                const partnerChildren = childCount - (d.children && d.children.some(c => !c.data.isPartner) ? 0 : 0);
                tooltipContent += `Familie: ${childCount} ${childCount === 1 ? 'Person' : 'Personen'}`;
            } else {
                tooltipContent += `${childCount} ${childCount === 1 ? 'Kind' : 'Kinder'}`;
            }

            tooltip.innerHTML = tooltipContent;
            tooltip.style.display = 'block';
            moveTooltip(event);
        }

        function moveTooltip(event) {
            const tooltip = document.getElementById('tooltip');
            tooltip.style.left = (event.pageX + 10) + 'px';
            tooltip.style.top = (event.pageY - 60) + 'px';
        }

        function hideTooltip() {
            document.getElementById('tooltip').style.display = 'none';
        }
    }
</script>
