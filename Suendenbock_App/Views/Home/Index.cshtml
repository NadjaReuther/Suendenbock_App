@{
        ViewData["Title"] = "Suendenbock - Fandom";
}
@model HomeViewModel

@section Styles {
        <link href="/css/fortune-wheel.css" rel="stylesheet" asp-append-version="true" />
}
<!-- Header -->
<header class="antique-header">
    <h1 class="main-title">Sündenbock 1618</h1>
</header>

<div class="main-container">
    <!-- Hero Pergament Karten mit echten Daten -->
    <section class="hero-section">
        
        <div class="pergament-card" data-tilt>
            <a class="card-link" asp-controller="Character" asp-action="Overview">
            <div class="card-corner top-left"></div>
            <div class="card-corner top-right"></div>
            <div class="card-corner bottom-left"></div>
            <div class="card-corner bottom-right"></div>

            <div class="card-number">@Model.Characters.Count</div>
            <h3 class="card-title">Charaktere</h3>
            <div class="card-content">
                Eingetragene Persönlichkeiten<br>
                aus allen Reichen und Ständen
            </div>
            </a>
        </div>
        
        <div class="pergament-card" data-tilt>
            <a class="card-link" asp-controller="Infanterie" asp-action="Overview">
            <div class="card-corner top-left"></div>
            <div class="card-corner top-right"></div>
            <div class="card-corner bottom-left"></div>
            <div class="card-corner bottom-right"></div>

            <div class="card-number">@Model.Infanteries.Count</div>
            <h3 class="card-title">Infanterien</h3>
            <div class="card-content">
                Organisierte Bünde<br>
                des Militärs
            </div>
            </a>
        </div>

        <div class="pergament-card" data-tilt>
            <a class="card-link" asp-controller="Guild" asp-action="Overview">
            <div class="card-corner top-left"></div>
            <div class="card-corner top-right"></div>
            <div class="card-corner bottom-left"></div>
            <div class="card-corner bottom-right"></div>

            <div class="card-number">@Model.Guilds.Count</div>
            <h3 class="card-title">Gilden</h3>
            <div class="card-content">
                Organisierte Bünde<br>
                für Abenteurer
            </div>
            </a>
        </div>
            <div class="pergament-card" data-tilt>
        <a class="card-link" asp-controller="Monstertyp" asp-action="Overview">

                <div class="card-corner top-left"></div>
                <div class="card-corner top-right"></div>
                <div class="card-corner bottom-left"></div>
                <div class="card-corner bottom-right"></div>

                <div class="card-number">@Model.Monstertyps.Count</div>
                <h3 class="card-title">Monstertypen</h3>
                <div class="card-content">
                    Ungeheuer und andere Wesen<br>
                    des Reiches
                </div>
            </a>
            </div>
        
    </section>
    <!-- Sternzeichen Übersicht -->
    <section class="zodiac-section">
                <h2 class="section-title">
                    <span class="title-decoration left">✨</span>
                    Sternzeichen
                    <span class="title-decoration right">✨</span>
                </h2>

                <div class="zodiac-chart-container">
                    <div class="zodiac-wheel-wrapper">
                        <div class="zodiac-pointer"></div>
                        <canvas id="zodiacChart"></canvas>
                        <div class="zodiac-center-button">
                            <span>Drehen!</span>
                        </div>
                    </div>
                    <div id="zodiac-result" class="zodiac-result" style="display: none;">
                        <div class="result-content">
                            <h3 id="result-title"></h3>
                            <p id="result-info"></p>
                        </div>
                    </div>
                    <div class="text-center mt-3">
                        <button id="resetButton" class="zodiac-reset-button" style="display: none;">
                            Zurück zur Startposition
                        </button>
                    </div>
                </div>
            </section>
    <section class="zodiac-section">
                <h2 class="section-title">
                    <span class="title-decoration left">✨</span>
                    Magie-System
                    <span class="title-decoration right">✨</span>
                </h2>

                <div class="zodiac-chart-container">
                    <div class="text-center mb-3">
                        <small style="font-family: 'Cinzel', serif; color: #5d4e37;">
                            <strong>Navigation:</strong> Klicke auf die Nodes (Kreise) um Zweige zu expandieren oder zu kollabieren
                        </small>
                    </div>

                    <!-- Tree Chart -->
                    <div id="tree-container" style="overflow-x: auto; overflow-y: auto;">
                        <svg id="tree-chart"></svg>
                    </div>

                    <!-- Tooltip -->
                    <div id="tooltip" style="
                        position: absolute;
                        display: none;
                        background: rgba(93, 78, 55, 0.95);
                        color: white;
                        padding: 10px 15px;
                        border-radius: 8px;
                        font-family: 'Cinzel', serif;
                        font-size: 0.9rem;
                        pointer-events: none;
                        z-index: 1000;
                        border: 2px solid #d4af37;
                        box-shadow: 0 4px 8px rgba(0,0,0,0.3);
                    "></div>
                </div>
            </section>
    <!-- Spielercharaktere Sektion -->
    <section class="guild-section">
        <h2 class="section-title">
            <span class="title-decoration left">⚔️</span>
            Unsere Helden
            <span class="title-decoration right">⚔️</span>
        </h2>

        <div class="character-scrolls">
            @if (Model.PlayerCharacters.Any() || Model.CompanionCharacters.Any())
            {
                @foreach (var character in Model.PlayerCharacters)
                {
                    <div class="character-scroll" data-tilt>
                        <a class="card-link" asp-controller="Character" asp-action="CharacterSheet" asp-route-id="@character.Id">
                            <div class="scroll-header">
                                @if (character.ImagePath == null)
                                {
                                    <div class="character-seal">@character.Vorname.FirstOrDefault()@character.Nachname.FirstOrDefault()</div>
                                }
                                else
                                {
                                    <img class="character-avatar-round" src="@character.ImagePath" alt="@character.Vorname @character.Nachname"/>
                                }
                            </div>
                            <div class="scroll-body">
                                <h4>@character.Vorname @character.Nachname</h4>
                                <span class="badge bg-primary">🎭 Spieler</span>
                            </div>
                        </a>
                    </div>
                }

                @foreach (var companion in Model.CompanionCharacters)
                {
                    <div class="character-scroll companion-character" data-tilt>
                        <a class="card-link" asp-controller="Character" asp-action="CharacterSheet" asp-route-id="@companion.Id">
                            <div class="scroll-header">
                                @if (companion.ImagePath == null)
                                {
                                    <div class="character-seal">@companion.Vorname.FirstOrDefault()@companion.Nachname.FirstOrDefault()</div>
                                }
                                else
                                {
                                    <img class="character-avatar-round" src="@companion.ImagePath" alt="@companion.Vorname @companion.Nachname"/>
                                }
                            </div>
                            <div class="scroll-body">
                                <h4>@companion.Vorname @companion.Nachname</h4>
                                <span class="badge bg-success">🤝 Begleiter</span>
                            </div>
                        </a>
                    </div>
                }
            }
            else
            {
                <p class="text-muted">Noch keine Spielercharaktere vorhanden.</p>
            }
        </div>
    </section>

    <!-- Statistiken mit Vintage-Design -->
    <section class="stats-section">
        <div class="stats-parchment">
            <div class="parchment-header">
                <h2 class="stats-title">Reichsstatistiken</h2>
            </div>

            <div class="stats-content">
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-icon">👨</div>
                        <span class="stat-number" data-target="@(Model.GenderStats.ContainsKey("männlich") ? Model.GenderStats["männlich"] : 0)">0</span>
                        <span class="stat-label">Männliche Charaktere</span>
                    </div>

                    <div class="stat-item">
                        <div class="stat-icon">👩</div>
                        <span class="stat-number" data-target="@(Model.GenderStats.ContainsKey("weiblich") ? Model.GenderStats["weiblich"] : 0)">0</span>
                        <span class="stat-label">Weibliche Charaktere</span>
                    </div>

                    <div class="stat-item">
                        <div class="stat-icon">🔮</div>
                        <span class="stat-number" data-target="@Model.Characters.Where(c => c.CharacterMagicClasses.Any()).Count()">0</span>
                        <span class="stat-label">Aktive Zauberer</span>
                    </div>

                    <div class="stat-item">
                        <div class="stat-icon">🚫</div>
                        <span class="stat-number" data-target="@Model.Characters.Where(c => c.Profan || c.Beschraenkt).Count()">0</span>
                        <span class="stat-label">Profane und Beschränkte</span>
                    </div>                    
                </div>
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-icon">💀</div>
                        <span class="stat-number" data-target="@Model.Characters.Where(c => c.Lebensstatus.Name != "lebend" && c.Lebensstatus.Name != "unbekannt").Count()">0</span>
                        <span class="stat-label">nicht lebend</span>
                    </div>
                    <div class="stat-item">
                        <div class="stat-icon">🙏</div>
                        <span class="stat-number" data-target="@Model.Characters.Where(c => c.Eindruck.Name == "Verbündeter").Count()">0</span>                        
                        <span class="stat-label">Verbündete</span>
                    </div>
                    <div class="stat-item">
                        <div class="stat-icon">🦄</div>
                        <span class="stat-number" data-target="@Model.Characters.Where(c => c.Rasse.Name != "Mensch").Count()">0</span>
                        <span class="stat-label">Supernatural</span>
                    </div>
                    <div class="stat-item">
                        <div class="stat-icon">👹</div>
                        <span class="stat-number">
                            @Model.Monsters.Count(c => c.meet) / @Model.Monsters.Count()
                        </span>
                        <span class="stat-label">freigespielte Monster</span>
                    </div>
                </div>

                <!-- Magiklassen-Verteilung -->
                <div class="magic-distribution">
                    <h3>Verteilung der Magieschulen</h3>
                    <div class="distribution-bars">
                        @foreach (var stat in Model.Obermagien)
                        {
                                // Tooltip-Content erstellen
                                var tooltipContent = "";
                                if (Model.MagicClassDetails.ContainsKey(stat.Key))
                                {
                                    var details = Model.MagicClassDetails[stat.Key];
                                    tooltipContent = string.Join("\n", details.Select(d => $"{d.Key}: {d.Value}"));
                                }
                            
                                <div class="distribution-item">
                                    <span class="distribution-label">@stat.Key</span>
                                    <div class="distribution-bar"
                                         data-bs-toggle="tooltip"
                                         data-bs-placement="top"
                                         data-bs-html="true"
                                         title="@Html.Raw(string.Join("<br>", Model.MagicClassDetails.ContainsKey(stat.Key) ? Model.MagicClassDetails[stat.Key].Select(d => $"{d.Key}: {d.Value}") : new List<string>()))"
                                         style="cursor: pointer;">
                                        <div class="distribution-fill" style="width: @(Math.Max(5, (stat.Value * 100) / Math.Max(1, Model.Obermagien.Values.Max())))%"></div>
                                        <span class="distribution-value">@stat.Value</span>
                                    </div>
                                </div>
                        }
                    </div>
                </div>
            </div>
        </div>
    </section>
</div>
<!-- D3.js Library -->
<script src="https://d3js.org/d3.v7.min.js"></script>

<style>
    .medieval-title {
        text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
    }

    /* Tree specific styles */
    #tree-chart .node circle {
        cursor: pointer;
        stroke: #5d4e37;
        stroke-width: 2px;
    }

    #tree-chart .node text {
        font-family: 'Cinzel', serif;
        font-size: 14px;
        font-weight: 600;
        fill: #5d4e37;
        text-shadow: 1px 1px 2px rgba(255,255,255,0.8);
    }

    #tree-chart .link {
        fill: none;
        stroke: #8b7355;
        stroke-width: 2px;
    }

    #tree-chart .node circle:hover {
        stroke: #d4af37;
        stroke-width: 3px;
    }
</style>

<script>
    // Mittelalterliches Farbschema
    const medievalColors = {
        gold: '#d4af37',
        darkBrown: '#5d4e37',
        mediumBrown: '#8b7355',
        lightBrown: '#a0826d',
        tan: '#c9a86a',
        parchment: '#f8f4e6'
    };

    // Farbzuweisung basierend auf Ebene
    function getNodeColor(depth) {
        switch(depth) {
            case 0: return medievalColors.gold;           // Root
            case 1: return medievalColors.mediumBrown;    // Obermagien
            case 2: return medievalColors.lightBrown;     // MagicClasses
            case 3: return medievalColors.tan;            // Specializations
            default: return medievalColors.darkBrown;
        }
    }

    // Lade Daten und erstelle Tree
    fetch('@Url.Action("GetHierarchyData", "MagicClass")')
        .then(response => response.json())
        .then(data => {
            createCollapsibleTree(data);
        })
        .catch(error => {
            console.error('Fehler beim Laden der Hierarchie-Daten:', error);
            document.getElementById('tree-container').innerHTML =
                '<div class="alert alert-danger">Fehler beim Laden der Daten. Bitte Seite neu laden.</div>';
        });

    function createCollapsibleTree(data) {
        // Dimensionen
        const margin = { top: 20, right: 120, bottom: 20, left: 120 };
        const width = 1200 - margin.left - margin.right;
        const height = 800 - margin.top - margin.bottom;

        // SVG erstellen
        const svg = d3.select("#tree-chart")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom);

        const g = svg.append("g")
            .attr("transform", `translate(${margin.left},${margin.top})`);

        // Separate Gruppen für Links (unten) und Nodes (oben)
        const linkGroup = g.append("g").attr("class", "links");
        const nodeGroup = g.append("g").attr("class", "nodes");

        // Tree Layout
        const tree = d3.tree()
            .size([height, width]);

        // Hierarchie erstellen
        const root = d3.hierarchy(data);
        root.x0 = height / 2;
        root.y0 = 0;

        // Variablen für die Update-Funktion
        var i = 0;
        const duration = 750;

        // Alle Kinder initial kollabieren (außer Root)
        if (root.children) {
            root.children.forEach(collapse);
        }

        update(root);

        function collapse(d) {
            if (d.children) {
                d._children = d.children;
                d._children.forEach(collapse);
                d.children = null;
            }
        }

        function update(source) {
            // Tree Layout anwenden
            const treeData = tree(root);
            const nodes = treeData.descendants();
            const links = treeData.links();

            // Normalisiere für feste Tiefe
            nodes.forEach(d => { d.y = d.depth * 200; });

            // **************** Nodes Sektion ****************

            // Update nodes
            const node = nodeGroup.selectAll('g.node')
                .data(nodes, d => d.id || (d.id = ++i));

            // Enter neue nodes
            const nodeEnter = node.enter().append('g')
                .attr('class', 'node')
                .attr("transform", d => `translate(${source.y0},${source.x0})`)
                .on('click', click);

            // Circles für die nodes
            nodeEnter.append('circle')
                .attr('r', 1e-6)
                .style("fill", d => d._children ? medievalColors.mediumBrown : medievalColors.parchment)
                .on("mouseover", function(event, d) {
                    d3.select(this)
                        .transition()
                        .duration(200)
                        .attr('r', 12);
                    showTooltip(event, d);
                })
                .on("mousemove", moveTooltip)
                .on("mouseout", function(event, d) {
                    d3.select(this)
                        .transition()
                        .duration(200)
                        .attr('r', 8);
                    hideTooltip();
                });

            // Labels für die nodes
            nodeEnter.append('text')
                .attr("dy", ".35em")
                .attr("x", d => d.depth === 0 ? -13 : 13)
                .attr("text-anchor", d => d.depth === 0 ? "end" : "start")
                .text(d => d.data.name)
                .style("fill-opacity", 1e-6);

            // Update
            const nodeUpdate = nodeEnter.merge(node);

            // Transition zur neuen Position
            nodeUpdate.transition()
                .duration(duration)
                .attr("transform", d => `translate(${d.y},${d.x})`);

            // Update circle Stil
            nodeUpdate.select('circle')
                .attr('r', 8)
                .style("fill", d => d._children ? getNodeColor(d.depth) : medievalColors.parchment)
                .style("stroke", d => getNodeColor(d.depth))
                .attr('cursor', 'pointer');

            // Update text
            nodeUpdate.select('text')
                .style("fill-opacity", 1);

            // Exit
            const nodeExit = node.exit().transition()
                .duration(duration)
                .attr("transform", d => `translate(${source.y},${source.x})`)
                .remove();

            nodeExit.select('circle')
                .attr('r', 1e-6);

            nodeExit.select('text')
                .style('fill-opacity', 1e-6);

            // **************** Links Sektion ****************

            // Update links
            const link = linkGroup.selectAll('path.link')
                .data(links, d => d.target.id);

            // Enter neue links
            const linkEnter = link.enter().append('path')
                .attr("class", "link")
                .attr('d', d => {
                    const o = { x: source.x0, y: source.y0 };
                    return diagonal(o, o);
                });

            // Update
            const linkUpdate = linkEnter.merge(link);

            // Transition zur neuen Position
            linkUpdate.transition()
                .duration(duration)
                .attr('d', d => diagonal(d.source, d.target));

            // Exit
            link.exit().transition()
                .duration(duration)
                .attr('d', d => {
                    const o = { x: source.x, y: source.y };
                    return diagonal(o, o);
                })
                .remove();

            // Speichere alte Positionen für Transition
            nodes.forEach(d => {
                d.x0 = d.x;
                d.y0 = d.y;
            });

            // Diagonale Pfad-Generator
            function diagonal(s, d) {
                return `M ${s.y} ${s.x}
                        C ${(s.y + d.y) / 2} ${s.x},
                          ${(s.y + d.y) / 2} ${d.x},
                          ${d.y} ${d.x}`;
            }

            // Toggle children on click
            function click(event, d) {
                if (d.children) {
                    d._children = d.children;
                    d.children = null;
                } else {
                    d.children = d._children;
                    d._children = null;
                }

                // Markiere den geklickten Node mit goldenem Hintergrund
                nodeGroup.selectAll('circle')
                    .style("fill", node => {
                        if (node === d) {
                            return medievalColors.gold; // Goldener Hintergrund für ausgewählten Node
                        }
                        return node._children ? getNodeColor(node.depth) : medievalColors.parchment;
                    });

                update(d);
            }
        }

        // Tooltip Funktionen
        function showTooltip(event, d) {
            const tooltip = document.getElementById('tooltip');
            const childCount = d.children ? d.children.length : (d._children ? d._children.length : 0);
            const depthLabel = d.depth === 0 ? 'System-Root' :
                              d.depth === 1 ? 'Obermagie' :
                              d.depth === 2 ? 'Magieklasse' :
                              d.depth === 3 ? 'Spezialisierung' : '';

            tooltip.innerHTML = `
                <strong>${d.data.name}</strong><br/>
                ${depthLabel}<br/>
                ${childCount > 0 ? `${childCount} ${childCount === 1 ? 'Unterelement' : 'Unterelemente'}` : 'Keine Unterelemente'}
            `;
            tooltip.style.display = 'block';
            moveTooltip(event);
        }

        function moveTooltip(event) {
            const tooltip = document.getElementById('tooltip');
            tooltip.style.left = (event.pageX + 15) + 'px';
            tooltip.style.top = (event.pageY + 15) + 'px';
        }

        function hideTooltip() {
            document.getElementById('tooltip').style.display = 'none';
        }
    }
</script>

@section Scripts {
    <!-- NEU: Chart.js Bibliothek einbinden -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

        <script>
            document.addEventListener('DOMContentLoaded', function() {
                // Bootstrap Tooltips initialisieren
                var tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'));
                var tooltipList = tooltipTriggerList.map(function (tooltipTriggerEl) {
                    return new bootstrap.Tooltip(tooltipTriggerEl);
                });

                // Animierte Zahlen für Statistiken
                const numbers = document.querySelectorAll('.stat-number');
                numbers.forEach(number => {
                    // Nur animieren, wenn data-target vorhanden ist
                    if (!number.hasAttribute('data-target')) {
                        return; // Überspringe Elemente ohne data-target
                    }

                    const target = parseInt(number.getAttribute('data-target'));
                    let current = 0;
                    const increment = target / 50;

                    const timer = setInterval(() => {
                        current += increment;
                        if (current >= target) {
                            number.textContent = target;
                            clearInterval(timer);
                        } else {
                            number.textContent = Math.floor(current);
                        }
                    }, 50);
                });

                // Tilt-Effekt für Karten
                document.querySelectorAll('[data-tilt]').forEach(card => {
                    card.addEventListener('mousemove', (e) => {
                        const rect = card.getBoundingClientRect();
                        const x = e.clientX - rect.left;
                        const y = e.clientY - rect.top;

                        const centerX = rect.width / 2;
                        const centerY = rect.height / 2;

                        const rotateX = (y - centerY) / 10;
                        const rotateY = (centerX - x) / 10;

                        card.style.transform = `perspective(1000px) rotateX(${rotateX}deg) rotateY(${rotateY}deg) scale3d(1.05, 1.05, 1.05)`;
                    });

                    card.addEventListener('mouseleave', () => {
                        card.style.transform = 'perspective(1000px) rotateX(0deg) rotateY(0deg) scale3d(1, 1, 1)';
                    });
                });

                // Parallax für Dekorationen
                window.addEventListener('scroll', () => {
                    const scrolled = window.pageYOffset;
                    const decorations = document.querySelectorAll('.vintage-decorations > div');

                    decorations.forEach((decoration, index) => {
                        const speed = (index % 3 + 1) * 0.1;
                        decoration.style.transform += ` translateY(${scrolled * speed}px)`;
                    });
                });

                // Schwebende Animation für Dekorationen
                document.querySelectorAll('.vintage-decorations > div').forEach((decoration, index) => {
                    decoration.style.animation = `float ${3 + index}s ease-in-out infinite`;
                    decoration.style.animationDelay = `${index * 0.5}s`;
                });
            });

        // Sternzeichen-Daten
        const zodiacDataFromServer = @Html.Raw(Json.Serialize(Model.ZodiacStats));

        const zodiacSigns = [
            {
                name: 'Widder',
                symbol: '♈',
                element: 'Feuer',
                info: 'bisher nicht aktiviert',
                characters: zodiacDataFromServer['Widder'] || []
            },
            {
                name: 'Stier',
                symbol: '♉',
                element: 'Erde',
                info: 'Effekt: Stände sind egal',
                characters: zodiacDataFromServer['Stier'] || []
            },
            {
                name: 'Zwillinge',
                symbol: '♊',
                element: 'Luft',
                info: 'Effekt: keine Lügen',
                characters: zodiacDataFromServer['Zwillinge'] || []
            },
            {
                name: 'Krebs',
                symbol: '♋',
                element: 'Wasser',
                info: 'Effekt: doppelter Sozialwert',
                characters: zodiacDataFromServer['Krebs'] || []
            },
            {
                name: 'Löwe',
                symbol: '♌',
                element: 'Feuer',
                info: 'Effekt: Nachteil bei Beeinflussung',
                characters: zodiacDataFromServer['Löwe'] || []
            },
            {
                name: 'Jungfrau',
                symbol: '♍',
                element: 'Erde',
                info: 'Effekt: Kritwerte halbiert',
                characters: zodiacDataFromServer['Jungfrau'] || []
            },
            {
                name: 'Waage',
                symbol: '♎',
                element: 'Luft',
                info: 'Effekt: keine Handelsfähigkeiten',
                characters: zodiacDataFromServer['Waage'] || []
            },
            {
                name: 'Skorpion',
                symbol: '♏',
                element: 'Wasser',
                info: 'Effekt: keine Menschenkenntnistalente',
                characters: zodiacDataFromServer['Skorpion'] || []
            },
            {
                name: 'Schütze',
                symbol: '♐',
                element: 'Feuer',
                info: 'bisher nicht aktiviert',
                characters: zodiacDataFromServer['Schütze'] || []
            },
            {
                name: 'Steinbock',
                symbol: '♑',
                element: 'Erde',
                info: 'Effekt: Wissenstalente im Vorteil',
                characters: zodiacDataFromServer['Steinbock'] || []
            },
            {
                name: 'Wassermann',
                symbol: '♒',
                element: 'Luft',
                info: 'Effekt: einen zusätzlichen Geistesblitzpunkt in Soziales',
                characters: zodiacDataFromServer['Wassermann'] || []
            },
            {
                name: 'Fische',
                symbol: '♓',
                element: 'Wasser',
                info: 'bisher nicht aktiviert',
                characters: zodiacDataFromServer['Fische'] || []
            }
        ];

        const elementColors = {
            'Feuer': '#8B0000',      // Dunkles Burgunderrot (wie Drachenblut-Pigment)
            'Erde': '#6B4423',       // Reiches Erdbraun (wie Umbra)
            'Luft': '#5F7A8A',       // Schieferblau (wie verblasstes Azurit)
            'Wasser': '#1B4D6D'      // Tiefes Marineblau (wie Indigo)
        };
        
        // Plugin zum Zeichnen der Symbole IN den Tortenstücken
        const zodiacSymbolPlugin = {
            id: 'zodiacSymbols',
            afterDatasetsDraw(chart) {
                const { ctx, chartArea: { width, height } } = chart;
                const centerX = width / 2;
                const centerY = height / 2;

                chart.data.datasets.forEach((dataset, datasetIndex) => {
                    const meta = chart.getDatasetMeta(datasetIndex);

                    meta.data.forEach((arc, index) => {
                        // Berechne die Mitte des Tortenstücks
                        const angle = (arc.startAngle + arc.endAngle) / 2;
                        const radius = (arc.innerRadius + arc.outerRadius) / 2;

                        // Position für das Symbol
                        const x = centerX + Math.cos(angle) * (radius+50);
                        const y = centerY + Math.sin(angle) * (radius+50);

                        // Symbol zeichnen
                        ctx.save();
                        ctx.font = 'bold 32px "Segoe UI Symbol", "DejaVu Sans", Arial';
                        ctx.fillStyle = '#ffffff';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';

                        // Schatten für bessere Lesbarkeit
                        ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
                        ctx.shadowBlur = 6;
                        ctx.shadowOffsetX = 2;
                        ctx.shadowOffsetY = 2;

                        // Zweimal zeichnen für solidere Farbe
                        ctx.fillText(zodiacSigns[index].symbol, x, y);
                        ctx.shadowColor = 'transparent';
                        ctx.fillText(zodiacSigns[index].symbol, x, y);
                        ctx.restore();
                    });
                });
            }
        };

        // Tortendiagramm erstellen
        const ctx = document.getElementById('zodiacChart').getContext('2d');
        new Chart(ctx, {
            type: 'pie',
            data: {
                labels: zodiacSigns.map(z => z.name), // Namen statt Symbole für Legende
                datasets: [{
                    data: Array(12).fill(1), // Alle gleich groß
                    backgroundColor: zodiacSigns.map(z => elementColors[z.element]),
                    borderWidth: 3,
                    borderColor: '#fff',
                    hoverBorderWidth: 5,
                    hoverBorderColor: '#6e4b1f'
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: true,
                plugins: {
                    legend: {
                         display: false
                    },
                    tooltip: {
                        enabled: true,
                        backgroundColor: 'rgba(110, 75, 31, 0.95)',
                        titleFont: { size: 18, family: 'Cinzel' },
                        bodyFont: { size: 14, family: 'MedievalSharp' },
                        padding: 15,
                        borderColor: '#d4af37',
                        borderWidth: 2,
                        callbacks: {
                            title: function(context) {
                                const index = context[0].dataIndex;
                                const sign = zodiacSigns[index];
                                return `${sign.symbol} ${sign.name}`;
                            },
                            label: function(context) {
                                return '';
                            },
                            afterLabel: function(context) {
                                const index = context.dataIndex;
                                const sign = zodiacSigns[index];

                                let lines = [
                                    `Element: ${sign.element}`,
                                    '',
                                    sign.info
                                ];

                                if (sign.characters.length > 0) {
                                    lines.push('');
                                    lines.push('Charaktere:');
                                    sign.characters.forEach(char => {
                                        lines.push(`• ${char}`);
                                    });
                                }

                                return lines;
                            }
                        }
                    }
                }
            },
            plugins: [zodiacSymbolPlugin]
        });

        // Chart-Referenz für spätere Manipulation speichern
        const zodiacChart = Chart.getChart('zodiacChart');

        // Glücksrad-Funktionalität
        let currentRotation = 0;
        let isSpinning = false;
        const canvas = document.getElementById('zodiacChart');
        const centerButton = document.querySelector('.zodiac-center-button');
        const resultDiv = document.getElementById('zodiac-result');
        const resultTitle = document.getElementById('result-title');
        const resultInfo = document.getElementById('result-info');
        const resetButton = document.getElementById('resetButton');

        centerButton.addEventListener('click', function() {
            if (isSpinning) return;

            // Tooltips deaktivieren für Glücksrad-Modus
            zodiacChart.options.plugins.tooltip.enabled = false;
            zodiacChart.update('none');

            // Spinning starten
            isSpinning = true;
            centerButton.classList.add('disabled');
            resultDiv.style.display = 'none';

            // Zufällige Anzahl an vollständigen Umdrehungen (5-8) plus zufällige Endposition
            const spins = 5 + Math.floor(Math.random() * 4); // 5-8 Umdrehungen
            const randomDegree = Math.floor(Math.random() * 360); // Zufällige Endposition
            const totalRotation = (spins * 360) + randomDegree;

            // Neue Gesamtrotation berechnen
            currentRotation += totalRotation;

            // Canvas drehen
            canvas.classList.add('spinning');
            canvas.style.transform = `rotate(${currentRotation}deg)`;

            // Nach der Animation: Ergebnis berechnen und anzeigen
            setTimeout(function() {
                // Normalisiere die Rotation auf 0-360 (positiv)
                const normalizedRotation = ((currentRotation % 360) + 360) % 360;

                // Das Rad dreht im Uhrzeigersinn
                // Bei 0° ist Segment 0 oben unter dem Pointer
                // Bei 30° ist Segment 11 oben (ein Segment zurück)
                // Bei 60° ist Segment 10 oben usw.

                // Berechne welches Segment unter dem Pointer ist
                // Wir müssen die Rotation umkehren und durch Segmentgröße teilen
                const segmentIndex = Math.floor((360 - normalizedRotation) / 30) % 12;

                // Hole das entsprechende Sternzeichen
                const selectedSign = zodiacSigns[segmentIndex];

                // Ergebnis anzeigen
                resultTitle.textContent = `${selectedSign.symbol} ${selectedSign.name}`;
                resultInfo.innerHTML = `
                    <strong>Element:</strong> ${selectedSign.element}<br>
                    <strong>Effekt:</strong> ${selectedSign.info}
                    ${selectedSign.characters.length > 0 ? '<br><br><strong>Charaktere mit diesem Sternzeichen:</strong><br>' + selectedSign.characters.join(', ') : ''}
                `;
                resultDiv.style.display = 'block';

                // Reset-Button anzeigen
                resetButton.style.display = 'inline-block';

                // Scroll zum Ergebnis
                setTimeout(function() {
                    resultDiv.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }, 100);

                // Button wieder aktivieren
                isSpinning = false;
                centerButton.classList.remove('disabled');
                canvas.classList.remove('spinning');
            }, 6000); // 6 Sekunden = Dauer der CSS-Transition
        });

        // Reset-Funktionalität
        resetButton.addEventListener('click', function() {
            // Rad zurück auf Startposition drehen
            currentRotation = 0;
            canvas.style.transition = 'transform 1s ease-out';
            canvas.style.transform = 'rotate(0deg)';

            // Tooltips wieder aktivieren
            zodiacChart.options.plugins.tooltip.enabled = true;
            zodiacChart.update('none');

            // UI zurücksetzen
            resultDiv.style.display = 'none';
            resetButton.style.display = 'none';

            // Transition zurücksetzen nach der Animation
            setTimeout(function() {
                canvas.style.transition = '';
            }, 1000);
        });
        </script>
}
