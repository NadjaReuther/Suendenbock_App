@{
    ViewData["Title"] = "Magie-Hierarchie";
    Layout = "~/Views/Shared/_Layout.cshtml";
}

<div class="container-fluid py-4">
    <div class="row justify-content-center">
        <div class="col-12">
            <!-- Header -->
            <div class="text-center mb-4">
                <h1 class="medieval-title" style="font-family: 'Cinzel', serif; color: #d4af37;">
                    üîÆ Magie-Hierarchie
                </h1>
                <p class="text-muted" style="font-family: 'Cinzel', serif;">
                    Interaktive Baumansicht der Obermagien, Magieklassen und Spezialisierungen
                </p>
            </div>

            <!-- Tree Container -->
            <div class="card" style="background: rgba(255, 248, 220, 0.95); border: 2px solid #d4c4a8; border-radius: 15px; box-shadow: 0 4px 12px rgba(0,0,0,0.3);">
                <div class="card-body p-4">
                    <!-- Legend -->
                    <div class="text-center mb-3">
                        <small style="font-family: 'Cinzel', serif; color: #5d4e37;">
                            <strong>Navigation:</strong> Klicke auf die Nodes (Kreise) um Zweige zu expandieren oder zu kollabieren
                        </small>
                    </div>

                    <!-- Tree Chart -->
                    <div id="tree-container" style="overflow-x: auto; overflow-y: auto;">
                        <svg id="tree-chart"></svg>
                    </div>

                    <!-- Tooltip -->
                    <div id="tooltip" style="
                        position: absolute;
                        display: none;
                        background: rgba(93, 78, 55, 0.95);
                        color: white;
                        padding: 10px 15px;
                        border-radius: 8px;
                        font-family: 'Cinzel', serif;
                        font-size: 0.9rem;
                        pointer-events: none;
                        z-index: 1000;
                        border: 2px solid #d4af37;
                        box-shadow: 0 4px 8px rgba(0,0,0,0.3);
                    "></div>
                </div>
            </div>

            <!-- Back Button -->
            <div class="text-center mt-4">
                <a href="@Url.Action("Index", "Home")" class="btn btn-outline-secondary" style="
                    font-family: 'Cinzel', serif;
                    border-color: #8b7355;
                    color: #5d4e37;
                ">
                    ‚Üê Zur√ºck zur Startseite
                </a>
            </div>
        </div>
    </div>
</div>

<!-- D3.js Library -->
<script src="https://d3js.org/d3.v7.min.js"></script>

<style>
    .medieval-title {
        text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
    }

    /* Tree specific styles */
    #tree-chart .node circle {
        cursor: pointer;
        stroke: #5d4e37;
        stroke-width: 2px;
    }

    #tree-chart .node text {
        font-family: 'Cinzel', serif;
        font-size: 14px;
        font-weight: 600;
        fill: #5d4e37;
        text-shadow: 1px 1px 2px rgba(255,255,255,0.8);
    }

    #tree-chart .link {
        fill: none;
        stroke: #8b7355;
        stroke-width: 2px;
    }

    #tree-chart .node circle:hover {
        stroke: #d4af37;
        stroke-width: 3px;
    }
</style>

<script>
    // Mittelalterliches Farbschema
    const medievalColors = {
        gold: '#d4af37',
        darkBrown: '#5d4e37',
        mediumBrown: '#8b7355',
        lightBrown: '#a0826d',
        tan: '#c9a86a',
        parchment: '#f8f4e6'
    };

    // Farbzuweisung basierend auf Ebene
    function getNodeColor(depth) {
        switch(depth) {
            case 0: return medievalColors.gold;           // Root
            case 1: return medievalColors.mediumBrown;    // Obermagien
            case 2: return medievalColors.lightBrown;     // MagicClasses
            case 3: return medievalColors.tan;            // Specializations
            default: return medievalColors.darkBrown;
        }
    }

    // Lade Daten und erstelle Tree
    fetch('@Url.Action("GetHierarchyData", "MagicClass")')
        .then(response => response.json())
        .then(data => {
            createCollapsibleTree(data);
        })
        .catch(error => {
            console.error('Fehler beim Laden der Hierarchie-Daten:', error);
            document.getElementById('tree-container').innerHTML =
                '<div class="alert alert-danger">Fehler beim Laden der Daten. Bitte Seite neu laden.</div>';
        });

    function createCollapsibleTree(data) {
        // Dimensionen
        const margin = { top: 20, right: 120, bottom: 20, left: 120 };
        const width = 1200 - margin.left - margin.right;
        const height = 800 - margin.top - margin.bottom;

        // SVG erstellen
        const svg = d3.select("#tree-chart")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom);

        const g = svg.append("g")
            .attr("transform", `translate(${margin.left},${margin.top})`);

        // Separate Gruppen f√ºr Links (unten) und Nodes (oben)
        const linkGroup = g.append("g").attr("class", "links");
        const nodeGroup = g.append("g").attr("class", "nodes");

        // Tree Layout
        const tree = d3.tree()
            .size([height, width]);

        // Hierarchie erstellen
        const root = d3.hierarchy(data);
        root.x0 = height / 2;
        root.y0 = 0;

        // Variablen f√ºr die Update-Funktion
        var i = 0;
        const duration = 750;

        // Alle Kinder initial kollabieren (au√üer Root)
        if (root.children) {
            root.children.forEach(collapse);
        }

        update(root);

        function collapse(d) {
            if (d.children) {
                d._children = d.children;
                d._children.forEach(collapse);
                d.children = null;
            }
        }

        function update(source) {
            // Tree Layout anwenden
            const treeData = tree(root);
            const nodes = treeData.descendants();
            const links = treeData.links();

            // Normalisiere f√ºr feste Tiefe
            nodes.forEach(d => { d.y = d.depth * 200; });

            // **************** Nodes Sektion ****************

            // Update nodes
            const node = nodeGroup.selectAll('g.node')
                .data(nodes, d => d.id || (d.id = ++i));

            // Enter neue nodes
            const nodeEnter = node.enter().append('g')
                .attr('class', 'node')
                .attr("transform", d => `translate(${source.y0},${source.x0})`)
                .on('click', click);

            // Circles f√ºr die nodes
            nodeEnter.append('circle')
                .attr('r', 1e-6)
                .style("fill", d => d._children ? medievalColors.mediumBrown : medievalColors.parchment)
                .on("mouseover", function(event, d) {
                    d3.select(this)
                        .transition()
                        .duration(200)
                        .attr('r', 12);
                    showTooltip(event, d);
                })
                .on("mousemove", moveTooltip)
                .on("mouseout", function(event, d) {
                    d3.select(this)
                        .transition()
                        .duration(200)
                        .attr('r', 8);
                    hideTooltip();
                });

            // Labels f√ºr die nodes
            nodeEnter.append('text')
                .attr("dy", ".35em")
                .attr("x", d => d.depth === 0 ? -13 : 13)
                .attr("text-anchor", d => d.depth === 0 ? "end" : "start")
                .text(d => d.data.name)
                .style("fill-opacity", 1e-6);

            // Update
            const nodeUpdate = nodeEnter.merge(node);

            // Transition zur neuen Position
            nodeUpdate.transition()
                .duration(duration)
                .attr("transform", d => `translate(${d.y},${d.x})`);

            // Update circle Stil
            nodeUpdate.select('circle')
                .attr('r', 8)
                .style("fill", d => d._children ? getNodeColor(d.depth) : medievalColors.parchment)
                .style("stroke", d => getNodeColor(d.depth))
                .attr('cursor', 'pointer');

            // Update text
            nodeUpdate.select('text')
                .style("fill-opacity", 1);

            // Exit
            const nodeExit = node.exit().transition()
                .duration(duration)
                .attr("transform", d => `translate(${source.y},${source.x})`)
                .remove();

            nodeExit.select('circle')
                .attr('r', 1e-6);

            nodeExit.select('text')
                .style('fill-opacity', 1e-6);

            // **************** Links Sektion ****************

            // Update links
            const link = linkGroup.selectAll('path.link')
                .data(links, d => d.target.id);

            // Enter neue links
            const linkEnter = link.enter().append('path')
                .attr("class", "link")
                .attr('d', d => {
                    const o = { x: source.x0, y: source.y0 };
                    return diagonal(o, o);
                });

            // Update
            const linkUpdate = linkEnter.merge(link);

            // Transition zur neuen Position
            linkUpdate.transition()
                .duration(duration)
                .attr('d', d => diagonal(d.source, d.target));

            // Exit
            link.exit().transition()
                .duration(duration)
                .attr('d', d => {
                    const o = { x: source.x, y: source.y };
                    return diagonal(o, o);
                })
                .remove();

            // Speichere alte Positionen f√ºr Transition
            nodes.forEach(d => {
                d.x0 = d.x;
                d.y0 = d.y;
            });

            // Diagonale Pfad-Generator
            function diagonal(s, d) {
                return `M ${s.y} ${s.x}
                        C ${(s.y + d.y) / 2} ${s.x},
                          ${(s.y + d.y) / 2} ${d.x},
                          ${d.y} ${d.x}`;
            }

            // Toggle children on click
            function click(event, d) {
                if (d.children) {
                    d._children = d.children;
                    d.children = null;
                } else {
                    d.children = d._children;
                    d._children = null;
                }

                // Markiere den geklickten Node mit goldenem Hintergrund
                nodeGroup.selectAll('circle')
                    .style("fill", node => {
                        if (node === d) {
                            return medievalColors.gold; // Goldener Hintergrund f√ºr ausgew√§hlten Node
                        }
                        return node._children ? getNodeColor(node.depth) : medievalColors.parchment;
                    });

                update(d);
            }
        }

        // Tooltip Funktionen
        function showTooltip(event, d) {
            const tooltip = document.getElementById('tooltip');
            const childCount = d.children ? d.children.length : (d._children ? d._children.length : 0);
            const depthLabel = d.depth === 0 ? 'System-Root' :
                              d.depth === 1 ? 'Obermagie' :
                              d.depth === 2 ? 'Magieklasse' :
                              d.depth === 3 ? 'Spezialisierung' : '';

            tooltip.innerHTML = `
                <strong>${d.data.name}</strong><br/>
                ${depthLabel}<br/>
                ${childCount > 0 ? `${childCount} ${childCount === 1 ? 'Unterelement' : 'Unterelemente'}` : 'Keine Unterelemente'}
            `;
            tooltip.style.display = 'block';
            moveTooltip(event);
        }

        function moveTooltip(event) {
            const tooltip = document.getElementById('tooltip');
            tooltip.style.left = (event.pageX + 15) + 'px';
            tooltip.style.top = (event.pageY + 15) + 'px';
        }

        function hideTooltip() {
            document.getElementById('tooltip').style.display = 'none';
        }
    }
</script>
